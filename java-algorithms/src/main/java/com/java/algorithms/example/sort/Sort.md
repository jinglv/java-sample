# 八大基础排序
## 冒泡排序
思路：
- 俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾
- 因为俩俩交换，需要n-1趟排序，比如10个数，需要9趟排序

代码实现要点：
- 两个for循环，外层循环控制排序的趟数，内层循环控制比较的次数
    - 每趟过后，比较的次数都应该要减1

优化：如果一趟排序后也没有交换位置，那么该数组已有序

### 例题分析
给定数组[2,1,7,9,5,8],要求按照从左到右、从小到大的顺序进行排序。

#### 解题思路
从左到右依次冒泡，把较大的数往右边挪动即可。
1. 首先指针指向第一个数，比较第一个数和第二个数的大小，由于2比1大，所以两两交换，[1, 2, 7, 9, 5, 8]。
2. 接下来指针往前移动一步，比较2和7，由于2比7小，两者保持不动，[1, 2, 7, 9, 5, 8]。到目前为止，7 是最大的那个数。
3. 指针继续往前移动，比较7和9，由于7比9小，两者保持不动，[1, 2, 7, 9, 5, 8]。现在，9 变成了最大的那个数。
4. 再往后，比较9和5，很明显，9比5大，交换它们的位置，[1, 2, 7, 5, 9, 8]。
5. 最后，比较9和8，9比8大，交换它们的位置，[1, 2, 7, 5, 8, 9]。经过第一轮的两两比较，9这个最大的数就像冒泡一样冒到了数组的最后面。

接下来进行第二轮的比较，把指针重新指向第一个元素，重复上面的操作，最后，数组变成了：[1, 2, 5, 7, 8, 9]。

#### 算法分析
##### 空间复杂度
假设数组的元素个数是n，由于在整个排序的过程中，我们是直接在给定的数组里面进行元素的两两交换，所以空间复杂度是O(1)。
##### 时间复杂度
1. 给定的数组按照顺序已经排好
    
    在这种情况下，我们只需要进行n−1次的比较，两两交换次数为0，时间复杂度是O(n)。这是最好的情况。
    
2. 给定的数组按照逆序排列

    在这种情况下，我们需要进行n(n-1)/2 次比较，时间复杂度是O(n^2)。这是最坏的情况。
    
3. 给定的数组杂乱无章

    在这种情况下，平均时间复杂度是O(n^2)。
    
由此可见，冒泡排序的时间复杂度是O(n^2)。它是一种**稳定**的排序算法。（**稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。**）

## 选择排序
思路：
- 找到数组中最大的元素，与数组最后一位元素交换
- 当只有一个数时，则不需要选择了，因此需要n-1趟排序，比如10个数，需要9趟排序

代码实现要点：
- 两个for循环，外层循环控制排序的趟数，内层循环找到当前趟数的最大值，随后与当前趟数组最后的一位元素交换

## 插入排序
思路：
- 将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素第一个元素看成是有序的
- 与有序的数组进行比较，比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入
- 当只有一个数时，则不需要插入了，因此需要n-1趟排序，比如10个数，需要9趟排序

代码实现：
- 一个for循环内嵌一个while循环实现，外层for循环控制需要排序的趟数，while循环找到合适的插入位置(并且插入的位置不能小于0)

特点：
- 在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，数组前端的数都是排好序的。

### 例题分析
对数组 [2, 1, 7, 9, 5, 8] 进行插入排序。

#### 解题思路
首先将数组分成左右两个部分，左边是已经排好序的部分，右边是还没有排好序的部分，刚开始，左边已排好序的部分只有第一个元素2。接下来，我们对右边的元素一个一个进行处理，将它们放到左边。
1. 先来看1，由于1比2小，需要将1插入到2的前面，做法很简单，两两交换位置即可，[1, 2, 7, 9, 5, 8]。
2. 然后，我们要把7插入到左边的部分，由于7已经比2大了，表明它是目前最大的元素，保持位置不变，[1, 2, 7, 9, 5, 8]。
3. 同理，9也不需要做位置变动，[1, 2, 7, 9, 5, 8]。
4. 接下来，如何把5插入到合适的位置。首先比较5和9，由于5比9小，两两交换，[1, 2, 7, 5, 9, 8]，继续，由于5比7小，两两交换，[1, 2, 5, 7, 9, 8]，最后，由于5比2大，此轮结束。
5. 最后一个数是8，由于8比9小，两两交换，[1, 2, 5, 7, 8, 9]，再比较7和8，发现8比7大，此轮结束。到此，插入排序完毕。

### 算法分析
#### 空间复杂度
假设数组的元素个数是n，由于在整个排序的过程中，是直接在给定的数组里面进行元素的两两交换，空间复杂度是O(1)。

#### 时间复杂度
1. 给定的数组按照顺序已经排好
    
    只需要进行 n-1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。
    
2. 给定的数组按照逆序排列

    在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是 O(n2)。这是最坏的情况。
    
3. 给定的数组杂乱无章

    在这种情况下，平均时间复杂度是 O(n2)。
    
由此可见，和冒泡排序一样，插入排序的时间复杂度是 O(n2)，并且它也是一种稳定的排序算法。

## 快速排序
思路：
- 在数组中找一个元素(节点)，比它小的放在节点的左边，比它大的放在节点右边。一趟下来，比节点小的在左边，比节点大的在右边。
- 不断执行这个操作....

代码实现：
- 快速排序用递归比较好写【如果不太熟悉递归的同学可到：递归就这么简单】。支点取中间，使用L和R表示数组的最小和最大位置
    - 不断进行比较，直到找到比支点小(大)的数，随后交换，不断减小范围～
- 递归L到支点前一个元素(j)(执行相同的操作,同上)
- 递归支点后一个元素(i)到R元素(执行相同的操作,同上)

## 归并排序
思路：
- 核心是分治，就是把一个复杂的问题分成两个或多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。归并排序将分治的思想体现得淋漓尽致。
- 将两个已排好序的数组合并成一个有序的数组。
    - 将元素分隔开来，看成是有序的数组，进行比较合并
    - 不断拆分和合并，直到只有一个元素

代码实现：
- 一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序
- 排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好

### 例题分析
利用归并排序算法对数组 [2, 1, 7, 9, 5, 8] 进行排序

#### 解题思路
首先不断地对数组进行切分，直到各个子数组里只包含一个元素。

接下来递归地按照大小顺序合并切分开的子数组，递归的顺序和二叉树里的前向遍历类似
1. 合并[2]和[1]为[1, 2]。
2. 子数组[1, 2]和[7]合并。
3. 右边，合并[9]和[5]。
4. 然后合并[5, 9]和[8]。
7. 最后合并[1, 2, 7]和[5, 8, 9]成[1, 2, 5, 8, 9]，就可以把整个数组排好序了。

合并数组[1, 2, 7]和[5, 8, 9]的操作步骤如下
1. 把数组[1, 2, 7]用L表示，[5, 8, 9]用R表示。
2. 合并的时候，开辟分配一个新数组T保存结果，数组大小应该是两个子数组长度的总和
3. 然后下标 i、j、k 分别指向每个数组的起始点。
4. 接下来，比较下标i和j所指向的元素L[i]和R[j]，按照大小顺序放入到下标k指向的地方，1小于5。
5. 移动i和k，继续比较L[i]和R[j]，2比5小。
6. i和k继续往前移动，5比7小。
7. 移动j和k，继续比较L[i]和R[j]，7比8小。
8. 这时候，左边的数组已经处理完毕，直接将右边数组剩余的元素放到结果数组里就好。

 
合并之所以能成功，先决条件必须是两个子数组都已经分别排好序了。

### 算法分析
#### 空间复杂度
由于合并 n 个元素需要分配一个大小为 n 的额外数组，合并完成之后，这个数组的空间就会被释放，所以算法的空间复杂度就是 O(n)。归并排序也是**稳定**的排序算法。

#### 时间复杂度
归并算法是一个不断递归的过程。


## 堆排序
思路：
- 堆排序使用到了完全二叉树的一个特性，根节点比左孩子和右孩子都要大，完成一次建堆的操作实质上是比较根节点和左孩子、右孩子的大小，大的交换到根节点上，直至最大的节点在树顶
- 随后与数组最后一位元素进行交换
- ......

代码实现：
- 只要左子树或右子树大于当前根节点，则替换。替换后会导致下面的子树发生了变化，因此同样需要进行比较，直至各个节点实现父>子这么一个条件

## 希尔排序
思路：
- 希尔排序实质上就是插入排序的增强版，希尔排序将数组分隔成n组来进行插入排序，直至该数组宏观上有序，最后再进行插入排序时就不用移动那么多次位置了～

代码思路：
- 希尔增量一般是gap = gap / 2，只是比普通版插入排序多了这么一个for循环罢了，难度并不大

## 基数排序
思路：
- 基数排序(桶排序)：将数字切割成个、十、百、千位放入到不同的桶子里，放一次就按桶子顺序回收一次，直至最大位数的数字放完～那么该数组就有序了

代码实现：
- 先找到数组的最大值，然后根据最大值/10来作为循环的条件(只要>0，那么就说明还有位数)
- 将个位、十位、...分配到桶子上，每分配一次就回收一次