# 设计模式
设计模式就是指导你如何写出可维护、可复用、可扩展及灵活的代码。

## 设计模式分类
设计模式总共有23种，总体来说可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns）。

分类 | 关注点 | 包含
--- | ---| ---
创建型模式 | 关注于对象的创建，同时隐藏创建逻辑 | 工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式 | 关注类和对象之间的组合 | 适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式
行为型模式 | 关注对象之间的通信 | 责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式

## 了解UML关系
- 泛化，可以简单地理解为继承关系；
- 实现，一般是接口和实现类之间的关系；
- 关联，一种拥有关系，比如老师类中有学生列表，那么老师类和学生类就是拥有关系；
- 聚合，整体与部分的关系，但是整体和部分是可以分离而独立存在的，如汽车类和轮胎类；
- 组合，整体与部分的关系，但是二者不可分离，分离了就没有意义了，例如，公司类和部门类，没有公司就没有部门；
- 依赖，一种使用关系，例如创建 A 类必须要有 B 类。

### 策略模式
策略模式定义了算法族(这里所说的算法并不是指 “ 冒泡排序算法 ” 、“ 搜索算法 ” 之类的算法，它可以是一段代码、一个请求、一个业务操作)，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

一般情况下我们是将一种行为写成一个类方法，比如计算器类中有加、减、乘、除四种方法，而策略模式则是将每一种算法都写成一个类，然后动态地选择使用哪一个算法。

举一个计算器的例子：

定义一个Operation.java的接口

### 装饰器模式
装饰器模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

装饰器模式中主要有两个角色：
- 装饰器
- 被装饰器的对象

假设一个例子：莉莉买衣服
- 莉莉就是**被装饰的对象**
- 衣服（帽子，裙子，裤子...）等就是**装饰器**

装饰器和被装饰的对象有两个特点，也是装饰器模式的关键：
- 他们实现同一个接口
- 装饰器中使用了被装饰的对象

例子实现com.java.design.pattern.sample.decorator

使用装饰器模式的几个关键点：
- 装饰器和被装饰类要实现同一个接口（ 实际开发中也可能用继承 ）。
- 装饰器中的方法可以调用被装饰对象提供的方法，以此实现功能累加的效果，例如，夹克装饰器和帽子装饰器中调用了 person.cost() + xx 实现累计消费金额的累加。

装饰器模式的作用是动态给对象增加一些功能，而不需要修改对象本身。
- 优点
    - 扩展功能的方式比较灵活
    - 每一个装饰器的相互独立，需要修改时不会互相影响
- 缺点
    - 多层装饰比较复杂，就像Java的IO流，初学起来不易理解
    
### 观察者模式
观察者模式定义了对象之间的**一对多**依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯

观察者模式有一个别名叫 “**订阅 — 发布模式**” 。报纸大家都订过吧，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，这是典型的订阅 — 发布模式，报社和订报纸的客户就是上面文章开头所说的 “ 一对多 ” 的依赖关系。

观察者模式就两种角色
- 一是观察者（订阅者）
- 二是被观察者（发布者）

观察者模式就是：当被观察者的**状态**改变了，就通知观察者

实例：用发布 — 订阅报纸的实例来说的话，就是客户们向报社订阅报纸，报社要保存一份所有客户的地址名单，然后有新报纸来了，就按照这个名单一个个派送报纸。

### 适配器模式
适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

适配器主要分为两种：
- 类适配器。
- 对象适配器。

### 单例模式
### 工厂模式