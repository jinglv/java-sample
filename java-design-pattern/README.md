# 设计模式
设计模式就是指导你如何写出可维护、可复用、可扩展及灵活的代码。

## 设计模式分类
设计模式总共有23种，总体来说可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns）。

分类 | 关注点 | 包含
--- | ---| ---
创建型模式 | 关注于对象的创建，同时隐藏创建逻辑 | 工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式 | 关注类和对象之间的组合 | 适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式
行为型模式 | 关注对象之间的通信 | 责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式

## 了解UML关系
- 泛化，可以简单地理解为继承关系；
- 实现，一般是接口和实现类之间的关系；
- 关联，一种拥有关系，比如老师类中有学生列表，那么老师类和学生类就是拥有关系；
- 聚合，整体与部分的关系，但是整体和部分是可以分离而独立存在的，如汽车类和轮胎类；
- 组合，整体与部分的关系，但是二者不可分离，分离了就没有意义了，例如，公司类和部门类，没有公司就没有部门；
- 依赖，一种使用关系，例如创建 A 类必须要有 B 类。

### 策略模式
策略模式定义了算法族(这里所说的算法并不是指 “ 冒泡排序算法 ” 、“ 搜索算法 ” 之类的算法，它可以是一段代码、一个请求、一个业务操作)，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

一般情况下我们是将一种行为写成一个类方法，比如计算器类中有加、减、乘、除四种方法，而策略模式则是将每一种算法都写成一个类，然后动态地选择使用哪一个算法。

举一个计算器的例子：

定义一个Operation.java的接口

### 装饰器模式
装饰器模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

装饰器模式中主要有两个角色：
- 装饰器
- 被装饰器的对象

假设一个例子：莉莉买衣服
- 莉莉就是**被装饰的对象**
- 衣服（帽子，裙子，裤子...）等就是**装饰器**

装饰器和被装饰的对象有两个特点，也是装饰器模式的关键：
- 他们实现同一个接口
- 装饰器中使用了被装饰的对象

例子实现com.java.design.pattern.sample.decorator

使用装饰器模式的几个关键点：
- 装饰器和被装饰类要实现同一个接口（ 实际开发中也可能用继承 ）。
- 装饰器中的方法可以调用被装饰对象提供的方法，以此实现功能累加的效果，例如，夹克装饰器和帽子装饰器中调用了 person.cost() + xx 实现累计消费金额的累加。

装饰器模式的作用是动态给对象增加一些功能，而不需要修改对象本身。
- 优点
    - 扩展功能的方式比较灵活
    - 每一个装饰器的相互独立，需要修改时不会互相影响
- 缺点
    - 多层装饰比较复杂，就像Java的IO流，初学起来不易理解